I Projet Cryptographie - Time-Memory Trade-Offs 1 Introduction 1.a Historique Jusqu’en 1980, avant le papier de Hellman [4], la cryptanalyse se faisait soit au détriment de la mémoire, soit au détriment du temps de recherche. Hellman propose alors une méthode faisant un compromis entre ces deux contraintes. Par la suite, en 1982, Rivest [7] propose une amélioration de ce compromis avec l’ajout de points distincts. 21 ans après, Oechslin [6] propose une autre amélioration du compromis tempsmémoire (TMTO), différente de celle de Rivest, les tables arc-en-ciel (rainbow tables). Deux ans plus tard, Gildas Avoine, Pascal Junod et Philippe Oechslin [1] proposent une avancée pour le compromis, l’ajout de points de contrôles (points utilisables aussi avec les points distincts ou les rainbow tables). Enfin, en 2006, Elad Barkan propose une variante se basant sur les rainbow tables et la méthode des points distincts [2], les rainbow tables floues. Puis en 2008, Jin Hong, Kyung Jeong, Eun Kwon, In-Sok Lee, et Daegun Ma proposent une variante à la méthode des points distincts. Depuis ces variantes, aucune avancée majeure n’a été publiée à ce sujet. 1.b Origines Dans son article « A Cryptanalytic Time-Memory Trade-Off » [4] publié en juillet 1980, Martin E. Hellman décrit pour la première fois un TMTO. Cette technique est à la base de nombreuses méthodes de cryptanalyse. De nombreux problèmes comme le logarithme discret ou le problème du sac à dos permettent l’utilisation de ce compromis. Pour N solutions à vérifier, le TMTO permet de trouver la solution en T opérations avec M mots de mémoire. On obtient alors le produit temps mémoire suivant : T M = N . La cryptanalyse est un problème de recherche permettant les deux extrêmes de recherches exhaustive (T = N , M = 1) et (T = 1, M = N ). Cependant, avant E. Hellman [4], aucun papier n’avait été publié sur un compromis entre les deux. De plus, avec des résultats de temps-mémoire tels que T = M = N 2/3 ou une complexité de M + T , le compromis est effectivement plus efficace et rentable qu’une recherche exhaustive ou une recherche de table. Ainsi, casser un DES 56bit avec cette méthode est moins complexe que de casser un DES 38-bit avec une recherche exhaustive. Cependant, pour les problèmes cités plus haut, le TMTO n’est pas des plus efficace, des solutions existants avec T = M = N 1/2 . Cela ne montre pas l’inefficacité du compromis mais que son amélioration est possible.  Une recherche exhaustive peut se faire avec une attaque par texte en clair (plaintext) connu, alors qu’une recherche par table nécessite une attaque par plaintext choisi. Dans une recherche exhaustive, le texte chiffré (ciphertext) peut être déchiffré pour chaque clé et comparé au plaintext. Si les textes sont identiques, après quelques tests additionnels rejetant les fausses alertes, la clé est trouvée. Dans une recherche par table, le cryptanalyste encrypte certains plaintext P0 pour chaque clé N possible. Ces N ciphertext sont enregistrés et triés dans des tables. Pour une nouvelle clé K et le ciphertext par cette clé C0 = SK (P0 ), le cryptanalyste retrouvera C0 et la clé correspondante en log2 N opérations. La méthode du TMTO fonctionne avec ce type d’attaque en plaintext choisi. De plus il fonctionne aussi avec une attaque par ciphertext seulement. Cependant, ce compromis est une méthode probabiliste. Le succès n’est pas garanti, il dépend des ressources allouées. Afin de comprendre les rainbow tables et leurs avantages par rapport à d’autres méthodes, nous allons commencer par expliquer le principe du TMTO. Puis nous présenterons les rainbow tables en les comparant à la méthode des points distincts. Nous détaillerons ensuite cette méthode des points distincts. Enfin nous verrons une amélioration notable de ces tables. 2 Principe de la méthode 2.a Principe Avec P0 un plaintext, C0 le ciphertext correspondant crypté avec S en utilisant une clé k ∈ N , on essaye de générer en avance, sous forme de chaîne, tous les ciphertext possible avec les N clés. Ne sont sauvegardés que le premier et le dernier élément de la chaîne afin de faire un TMTO. Pour générer les clés, une fonction de réduction R est appliquée aux ciphertext : Sk (P0 )  R(Ci )  i ki −→ Ci −→ ki+1  Cette succession de S et de R est appelée f avec f (ki ) = R(Ski (P0 )). Pour retrouver la clé d’un ciphertext, l’algorithme de recherche génère une clé avec le ciphertext (k ′ = R(C ′ )) et fait une chaîne de la taille de celles qui ont été stockées. Si une des clés générées correspond à une des clés sauvegardées, il suffit de reconstruire la chaîne concernée et de retrouver l’emplacement qui correspond à la clé avant R(C ′ ). 2.b Une amélioration  Nous pouvons noté que assez rapidement une amélioration a été proposé par Rivest [7], cette amélioration consiste à utiliser un critère d’arrêt au lieu de générer des chaînes de taille fixe. Ainsi, la recherche d’une clé généré dans une table n’est réalisé que si cette clé respecte le critère d’arrêt, réduisant de ce fait le nombre de recherche dans une table. Cependant, plus la table est grande et plus les chances que deux chaînes commençant différemment entrent en collision et finissent avec les mêmes clés. La probabilité que ça arrive, d’après le papier original [4], dans une table de m lignes de t clés :  Ptable ≥  m ∑ t−1 1 ∑ it (1 − )j+1 N i=1 j=0 N  Afin d’augmenter l’efficacité, il faudrait générer plusieurs tables l avec des fonctions de réduction différentes. De plus, attention aux fausses alertes. Ce n’est pas parce que la chaîne générée parait être dans la table qu’elle l’est forcément. De par les collisions, deux chaînes peuvent se finir pareil sans démarrer au même point. 2.c Paramètres Il y a, dans cette méthode de TMTO, trois paramètres pouvant être ajustés : la taille des chaînes t, le nombre de chaînes par table m et le nombre de tables l. Ils permettent d’ajuster les limites sur la mémoire M , le temps de cryptanalyse T et la probabilité de succès Psuccess [6] :  M = m ∗ l ∗ m0 T = t ∗ l ∗ t0 Psuccess ≥ 1 − (1 −  t−1 m ∑ it 1 ∑ (1 − )j+1 )l N i=1 j=0 N  Le TMTO a été décrit pour une utilisation avec un chiffrement par bloc [4], mais la même approche fonctionne avec un chiffrement de flux synchrone [4]. Les k premiers bits du flux de clés sont considérés comme la fonction f (k), k étant le nombre de bits de la clé. Cela peut être fait sous une attaque en texte clair connue. La méthode fonctionne sur tous les systèmes dans une attaque en plaintext choisi mais ne fonctionne pas avec une attaque en plaintext connu sur un système  de retour de chiffrement si la charge initiale du registre à décalage est aléatoire et varie entre les conversations. Les normes fédérales proposées [4] suggèrent cette précaution. De plus, même un chiffrement par bloc peut contrecarrer le TMTO d’une attaque en plaintext connu par le chaînage de blocs de chiffrement ou d’autres techniques introduisant de la mémoire dans le chiffrement. Ensuite, même lorsque huit espaces apparaissent dans le texte en clair, leur chiffrement dépend du texte précédent. Même si le premier bloc de texte est assez standard (par exemple, “Login:”), cette technique peut être déjouée par la transmission d’un “indicateur” aléatoire servant à affecter le chiffrement (par exemple, il est considéré comme le bloc de texte). Encore une fois, les normes proposées [4] incluent des dispositions pour l’enchaînement des blocs de chiffrement avec un indicateur aléatoire. Bien que cette technique cryptanalytique de TMTO puisse être facilement déjouée, elle fonctionne sur le DES, en mode bloc de base, nécessaire pour avoir une assurance raisonnable de sécurité. Bien que la recherche de table et la recherche exhaustive soient actuellement irréalisables sur les systèmes dotés de tailles de clé supérieures ou égales à 64 bits, un compromis N 1/2 en termes de mémoire temps porterait la taille minimale de clé utilisable à 128 bits. La technique N 2/3 décrite ici, associée au grand nombre de compromis de mémoire temporelle N 1/2 connus pour d’autres problèmes de recherche, indique que les données de valeur ne doivent pas être confiées à un appareil avec une taille de clé inférieure. 3 Tables arc-en-ciel 3.a Comparaison et avantages Le problème des précédentes tables est que si deux chaînes entrent en collision, elles fusionnent. Il existe des méthodes pour que deux chaînes en collision ne fusionnent pas, les rainbow tables. Le principe : elles utilisent des fonctions de réductions différentes à chaque point de la chaîne. Les chances que deux chaînes fusionnent étaient de 1 avec la méthode classique [6], avec les rainbow tables les chances de fusion sont de 1t . Le succès pour une table de taille m ∗ t : t  Ptable = 1 − Π (1 − i=1  mi ) N  Il est intéressant de noter que la probabilité de succès de t tables classiques m ∗ t est la même qu’une rainbow table mt ∗ t. Ces tables offrent les mêmes avantages que les tables classiques sans certains inconvénients : – La recherche dans les tables est diminuée d’un facteur t. – Il est facile de générer des tables sans fusion mais elles comporteront alors forcément des collisions. – Les rainbow tables ont une taille constante tandis que les chaînes à point distincts ont une taille variable. Ce qui réduit considérablement les fausses alertes. 3.b Expérimentations Le travail de Philippe Oechslin [6] nous permet d’obtenir des résultats expérimentaux comparant les tables à points distincts et les rainbow tables. Oechslin utilise comme test le crack de mots de passes du LanManager de MS Windows car il peut être effectué sur n’importe quel poste de travail standard. En se basant sur les paramètres exprimés plus haut, il a choisit les valeurs suivantes pour les deux types de tables afin de comparer les résultats (après 500 mots de passes craqués) ; t, m, l predicted coverage measured coverage  Classique avec PC 4666, 8192, 4666 75.5% 75.8%  Arc-en-ciel 4666, 38 223 872, 1 77.5% 78.8%  Cette expérimentation montre que pour la même quantité de données, les rainbow tables ont la même probabilité de succès que les tables classiques avec points caractéristiques. En comparant le temps de cryptanalyse, le nombre d’opérations, et le nombre de fausses alertes par cryptanalyses, la rainbow table est 7 fois plus rapides et contient 2.8 fois moins de fausses alertes, ce qui réduit aussi le nombre d’opérations par cryptanalyse de 7.1 fois. Cela se traduit par le fait que la tailles des chaînes dans les tables classiques n’est pas constante. On voit alors ressortir l’importance pour les chaînes d’être constante. Deux points ressortent concernant la constance des chaînes [6] : – Attraction fatale : La variation de la longueur des chaînes entraîne une variation de la probabilité de fusion. Cela pose problème avec les fausses alertes. Elles apparaîtront plus fréquemment dans des grandes chaînes de par la fusion.  – Frais plus important : Une fausse alerte dans une grande chaîne va demander beaucoup de calculs, cette chaîne ayant une grande chance de fusionner avec une autre grande chaîne, ce qui augmente le coût pour vérifier la fausse alerte. De plus, lorsque la taille de la chaîne est inconnue, il faut regénérer toute la chaîne. 3.c Pistes d’améliorations La méthode de calcul peut encore être améliorée. Pour les rainbow tables, 2 la quantité de calculs augmente de façon quadratique de 1 à t 2−1 . Pour les tables classiques, c’est une augmentation linéaire t2 . Pour augmenter les chances de succès et la rapidité, il faut augmenter le nombre de rainbow tables et regarder les lignes de toutes les tables en même temps. En prenant l’exemple précédent avec 78% de succès avec une table, avec 5 tables le succès passe à 99.9%. Le résultat se trouvant dans les premières lignes, cela diminue le temps de recherche nécessaire. Ce n’est évidemment pas la seule amélioration possible. 4 Méthode des Points Distincts et ses variantes Comme nous l’avons vue précédement la méthode des points distincts introduites en 1982 [7], consiste à fixer un critère d’arrêt. Ainsi, nous vérifions si le dernier élément de la chaîne se trouve dans une table seulement s’il respecte le même critère d’arrêt, limitant de ce fait le nombre de ces vérification. Cette technique semble avoir un intérêt limité pour les rainbow tables. Mais de nombreuses recherches ont été mené menant a des solutions novatrice. 4.a Méthodes des points distincts Comme nous l’avons vue, nous créons des chaînes de taille variable, mais nous fixons des bornes par sécurité. En effet une chaîne peut réaliser une boucle en fusionnant avec elle-même et par conséquant ne jamais vérifier la condition d’arrêt. C’est pourquoi nous posons t̂ = tmax la limite haute avant d’écarter une chaîne. De même, nous fixons une limite basse ť = tmin afin d’éviter d’avoir des chaînes trop courte. Ainsi nous pouvons appliqué la méthode des points distincts aux rainbow tables en fixant t̂ fonctions de réduction. Toutes ne seront pas utilisés, mais nous en auront le minimun requis pour appliquer cette technique. Etant donné que les chaînes des tables s’arrêtent au premier point distinct compris dans les bornes, si nous ne trouvons pas de correspondance entre la chaîne que nous générons et une table, alors nous pouvons être sûr que notre clé ne se trouve pas dans cette table. Ainsi par table, nous ne réalisons qu’une seule vérification. Le nombre de vérification nécessaire est estimé être réduit par un facteur de 2d où d = 13 log2 N  Le plus gros défaut de cette technique est la nécessité de stocker la taille des chaînes, ce qui rajoute un coût non-négligeable. C’est une des raisons pour lesquelles cette technique n’apporte que peu d’avantage en essayant de l’appliquer aux rainbow tables. 4.b Première Variante Une première idée proposé dans cet article [5], est de faire varier la condition d’arrêt en fonction du point de départ. L’un des avantages est qu’ainsi nous avons des informations sur le point de départ dans le point final. La conséquence est que nous ne sommes plus obliger de stocker le point de départ. Malheureusement cette technique ne semble pas plus efficace qu’une rainbow table classique [5, 8]. Nous avons d’ailleurs les résultats d’une analyse théorique dans le tableau proposé par [5] joint ci-dessous. Nous verrons plus en détail la méthode de comparaison utilisé en section 5.c. nombre d’entrée par table (M )  nombre de recherche dans la table  nombre d’évaluations de fonction  équation de la courbe de compromis  Hellman  mt  t2  t2  TM2 = N2  Arc-en-ciel  mt  t  1 2 t 2  T M 2 = 12 N 2  Hellman+DP  mt  t  1 2 t 2  T M 2 = 12 N 2 TM2 = c∗N2  Hellman+VDP  mt  t ∗ t̂  t ∗ t̂  Arc-en-ciel+DP  mt  t̂  1 2 t̂ 2  TM2 =  c2 N2 2  Arc-en-ciel+VDP  mt  1 2 t̂ 2  1 2 t̂ 2  TM2 =  c2 N2 2  Où nous avons t̂ = tmax = c ∗ t, de plus ces donnés sont calculés selon le pire des cas. Mais comme nous pouvons le constater le facteur c, dans l’équation de la courbe du copromis, a de forte chance de limiter l’intérêt de ces tables. Ainsi dans l’article [5], les auteurs ont cherché les paramètres optimaux pour rendre cette technique viable, mais ils n’y sont pas parvenue. 4.c Les tables arc-en-ciel floues Une autre alternative a été proposé [2] dont l’idée consiste à agréger différntes de tables de Hellman associé à la technique des points distincts. Nous obtenons ainsi une rainbow table où en lieu et place de changer de fonction de réduction pour chaque colonne, nous en changeons à chaque fois que nous respectons le critère  d’arrêt. Nous obtenons alors le modèle ci-dessous. La mise en place plus pratique a été étudié par [3] DP  DP  DP  DP  SP • f1 f1 f1 . . . f1 • f2 f2 f2 . . . f2 • f3 f3 f3 . . . f3 • . . . • fs fs fs . . . fs •EP |  {z  ∼t  }  |  {z  ∼t  }  |  {z  ∼t  }  |  {z  ∼t  }  4.d Conclusion La méthode des points distincts est encore aujourd’hui exploré mais jusqu’à présent elle n’a pas donné de résultat probant. Une autre méthode pour limiter le coût des recherches dans les tables a été présenté par [1] en 2005. C’est une méthode basé sur des points de contrôle. Nous la verrons plus en détail dans la prochaine section. 5 Améliorations notables : fausses alertes et outils de mesure Comme nous l’avons vue précédemment (section 3) le problème de fusion de chaîne a amené a créé les rainbow tables. Mais il se peut aussi qu’il y ait collision entre la chaîne que nous générons et une des chaînes des tables. Lorsque ce cas arrive nous parlons de fausse alertes [1]. De plus jusqu’à présent nous n’avons pas réellement présenté d’outils permettant de comparer les efficacités des différentes méthodes de TMTO. 5.a Points de contrôles Afin de vérifier que 2 chaînes ne fusionnent il a été proposé par [1] d’instaurer des points de contrôles. Pour ce faire αi positions sont fixées. Pour chaque chaîne, la fonction G est évaluée et la valeur est stockée, à chacune de ces positions. Lors de la génération de la chaîne Y1 ,Y2 , . . . ,Ys nous évaluons également les G(Yαi +s−t ). La moindre différence entre les points de contrôles de cette chaîne et celle de la table correspond à une fausse alerte. les points de contrôle doivent être simple à évaluer et stocker, il est considéré que g sort les bits les moins significatifs. nous estimons selon la formule suivante la détection d’une fausse alerte : 1 1 1 pr{g(xj,α ) ̸= g(yα+s−t ) | xj,a ̸= yα+s−t } = (1 − |k| ) ≈ 2 2 2 Suite à l’introduction de ces points de contrôles, nous pouvons nous retrouver dans 2 cas : – soit le point de contrôle se trouve avant la fusion (figure de gauche ci-dessous), auquel cas nous pouvons détecté une fausse alerte avec une probabilité de 12 comme vue ci-dessus – soit le point de contrôle se trouve après la fusion (figure de droite ci-dessous)  Fig. 5.1: Fausse alerte détectée  Fig. 5.2: Fausse alerte non détectée  5.b Tables parfaites Cette notion de fusion et de points de contrôles introduit alors un nouveau concept les tables dites parfaites, des tables sans fusion. En effet comme l’équation de la courbe de compromis est de la forme T M 2 = α ∗ N 2 , afin de profiter au maximum du TMTO il faut minimiser le coût mémoriel qui est élevé au carré. Et pour ce faire nous devons éviter de stocker de l’information redondante. Pour créer une table de Hellman parfaite, il faut vérifier que chaque élément de la table soit distinct, ce qui est extrêmement coûteux à réaliser lors de la phase de pré-calcul. C’est vérification est nécessaire car une chaîne peut fusionner à n’importe quelle position d’une autre chaîne. Afin de vérifier si une rainbow table est parfaite, il suffit de vérifier que chaque élément de fin de chaîne est distinct. Cette vérification est suffisant car la fonction de réduction change à chaque colonne. De même, pour vérifier si une table de Hellman associé à la méthode des points distincts est parfaite, il suffit également de vérifier que chaque dernier éléments est distincts. Cette vérification est suffisante car peut importe où commence la fusion dans tous les cas elle amènera au même point qui respecte le critère d’arrêt. 5.c Outils de comparaison En connaissant les fonctions caractéristiques il est possible de tracer les graphiques temps-mémoire pour un taux de succès fixé. Ces graphiques montre que le temps de calcul diminue avec le carré de la mémoire utilisée.  T =  N2 γ(P ) M2  Où γ(P ) est facteur dépendant du taux de succès. Le cas optimal de P=86% selon [1] donne un facteur de un. Il est possible alors de retrouvé le compromis  2  typique proposé par Hellman [4], M = T = N 3 . La formule ?? permet de trouver un des paramètres optimaux, en se basant sur les 2 autres. Afin de comparer l’efficacité des différentes types méthodes de TMTO, il est possible d’étudier l’évolution de γP . Les tables classiques et DP peuvent aussi être caractérisées par le facteur γ. Dans cet étude, il a été choisi de générer les plus grosses tables parfaites possibles, et autant de table que nécessaire pour atteindre un taux de succès P fixé. Les caractéristiques sont tracés en figure 5.3, par ailleurs les sauts de la courbe de la méthode rainbow table correspond à la nécessité d’une table supplémentaire.  Fig. 5.3: Graphique Temps-Mémoire pour les tables classiques, arc-en-ciel et DP La théorie et l’expérience montre qu’à partir d’un taux de succès de 80%, les rainbow tables proposent le meilleur compromis. En-dessous de ce taux, il semblerait que les tables classiques soit un peu meilleure. Mais elles conservent un coût de temps de calcul plus élevé, lié à la nécessité de t fois plus de boucles lors de la recherche dans les tables. 5.d Conclusion La méthode des points de contrôles est une évolution extrêmement intéressante qui permet de limiter le coût en temps de calcul, de plus elle peut s’appliquer à toutes les méthodes de TMTO. Nous avons également vue plus en détail la méthode de comparaison entre les différentes méthodes de TMTO. 6 Conclusion Nous avons vue l’introduction des TMTO par Hellman en 1980, qui est une idée totalement novatrice. Puis, une nouvelle version de cette méthode proposé par Oeschlin en 2003 avec les rainbow tables. Entre temps la méthode des points distincts, proposé par Rivest en 1982, a été améliorée à différents reprise sans  jamais être équivalente aux rainbow tables. Enfin nous avons découvert les points de contrôles et les tables parfaites, ainsi que l’équation permettant de comparer les différentes méthodes de compromis. Il ressort de cette étude des différentes méthode de TMTO que pour l’instant la méthode des rainbow tables est la méthode offrant généralement la meilleure solution. Même si la recherche reste active, cette méthode semble être la meilleure que nous puissions obtenir sans exploiter la forme de la fonction à inverser. Jusqu’à présent ces méthodes étaient surtout connues pour permettre d’inverser une fonction de hachage, et ainsi attaquer les bases de données où sont stockés les mots de passes hashés. Mais pour faire à ce type d’attaque, un suffixe est ajouté aux mots de passe avant la phase de hashage, il s’agit du sel. Il faut alors reconstitué notre rainbow table pour chaque sel différent. Ceci étant dit il peut être utile cela peut être intéressant car les bases de données attaqués contiennent généralement des milliers de mots de passes. Une autre utilisation des TMTO qui pour l’instant ne semble pas trop utilisé est l’attaque par mot en clair choisie pour inverser une clé de chiffrement tel que proposé par Hellman. Au-delà, de leurs intérêts en attaque informatique, les TMTO sont également d’excellent outils à étudier d’un point de vue mathématiques. Et c’est pour toutes ces raisons que nous pensons que ces méthodes ne vont pas disparaître d’ici peu.  Références [1] Gildas Avoine, Pascal Junod, and Philippe Oechslin. Time-memory tradeoffs: False alarms detection using checkpoints. Technical report, Lausanne, Switzerland, September 2005. [2] Elad Barkan. Cryptanalysis of Ciphers and Protocols. PhD thesis, Technion Israel Institute of Technology, April 2006. [3] Mahmoud Haghighi and Mohammad Dakhilalian. A practical time complexity analysis of fuzzy rainbow tradeoff. pages 39–43, 09 2014. [4] Martin Hellman. A cryptanalytic time-memory trade-off. IEEE transactions on Information Theory, 26(4):401–406, 1980. [5] Jin Hong, Kyung Jeong, Eun Kwon, In-Sok Lee, and Daegun Ma. Variants of the distinguished point method for cryptanalytic time memory trade-offs. volume 4991, pages 131–145, 04 2008. [6] Philippe Oechslin. Making a faster cryptanalytic time-memory trade-off. In Annual International Cryptology Conference, pages 617–630. Springer, 2003. [7] Dorothy Elizabeth Robling Denning. Cryptography and data security, page 100. Addison-Wesley Longman Publishing Co., Inc., 1982. [8] Wenhao Wang. Notes on rainbow distinguished point method. arXiv preprint arXiv:1506.00794, 2015.  12   