\setsection{Principes et origines}

	The time-memory trade-off was described for use with a block cipher, but the same approach works with a synchronous stream cipher [7]. The first k bits of keystream are taken as the f(K) function, where k is the number of bits of key. This can be done under a known plaintext attack.\\

	The method works on all systems in a chosen plaintext attack [7] but does not work with a known plaintext attack on a cipher feedback system [7] if the initial load of the shift register is random and varies between conversations. Proposed Federal standards suggest this precaution.\\

	Even a block cipher can foil the time-memory trade-off in a known plaintext attack through cipher block chaining [7], [8] or other techniques which introduce memory into the encipherment. Then, even when eight blanks occur in the plaintext, their encipherment depends on the preced- ing text. Even if the first block of text is fairly standard (e.g., “Login: “), this technique can be foiled by the transmission oFa random “indicator”  which is used to affect the encipherment (e.g., it is taken as the 0th plain- text block). Again, proposed standards include provision for cipher block chaining with a random indicator.\\

	While this time-memory trade-off cryptanalytic tech- nique can be easily foiled, it does work on the DES in basic block mode, More importantly, it indicates that even when cipher block chaining or other techniques are added, a larger key size is needed to have a reasonable assurance of security. While table lookup and exhaustive search are currently infeasible on systems with 64-bit or larger key sizes, an N *I2 time-memory trade-off would push the minimum usable key size up to 128 bits. The N213 technique described here, coupled with the large number of N’12 time-memory tradeoffs known for other searching problems, indicates that valuable data should not be entrusted to a device with smaller key size.

%	Add Hellman 36.pdf

	Avec $P_0$ un \gls{plaint}, $C_0$ le \gls{cipher} correspondant crypté avec $S$ en utilisant une clé $k \in N$, on essaye de générer en avance, sous forme de chaîne, tous les \gls{cipher} possible avec les $N$ clés. Ne sont sauvegardés que le premier et le dernier élément de la chaîne afin de faire un compromis temps-mémoire. Pour générer les clés, une fonction de réduction $R$ est appliquée aux \gls{cipher} :

	\begin{align*}
		k_i \overset{S_{k_i}(P_0)}{\longrightarrow} C_i \overset{R(C_i)}{\longrightarrow} k_{i+1}
	\end{align*}

	Cette succession de $S$ et de $R$ est appelée $f$.\\

	Pour retrouver la clé d'un \gls{cipher}, il génère une clé avec le \gls{cipher} ( $k' = R(C')$ ) et il fait une chaîne de la taille de celles qui ont été stockées. Si une des clés générées correspond à une des clés sauvegardées, il suffit de reconstruire la chaîne concernée et de retrouver l'emplacement qui correspond à la clé avant $R(C')$.

	Cependant, plus la table est grande et plus les chances que deux chaînes commençant différement entrent en collision et finissent avec les mêmes clés. La probabilité que ça arrive, d'après le papier original\cite{ehellman}, dans une table de $m$ lignes de $t$ clés :\\

	\begin{align*}
		P_{table} \ge{} \frac{1}{N} \Sum{i=1}{m}\Sum{j=0}{t-1} (1 - \frac{it}{N})^{j+1}
	\end{align*}

	Afin d'augmenter l'efficacité, il faudrait générer plusieurs tables $l$ avec des fonctions de réduction différentes. De plus, attention aux fausses alertes. Ce n'est pas parce que la chaîne générée parait être dans la table qu'elle l'est forcément. De par les collisions, deux chaînes peuvent se finir pareil sans démarrer au même point.\\

	Il y a, dans cette méthode de compromis temps-mémoire, trois paramètres pouvant être ajustés : la taille des chaînes $t$, le nombre de chaînes par table $m$ et le nombre de tables $l$. Ils permettent d'ajuster les limites sur la mémoire $M$, le temps de cryptanalyse $T$ et la probabilité de succès $P_{success}$\cite{Oech03} :

	\begin{align*}
		M &= m*l*m_0\\
		T &= t*l*t_0\\
		P_{success} &\ge{} 1 - (1 - \frac{1}{N} \Sum{i=1}{m}\Sum{j=0}{t-1} (1 - \frac{it}{N})^{j+1})^l
	\end{align*}

	\clearpage

\endinput{}
